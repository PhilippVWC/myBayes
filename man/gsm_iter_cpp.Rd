% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{gsm_iter_cpp}
\alias{gsm_iter_cpp}
\title{Time series creation}
\usage{
gsm_iter_cpp(N, x0, r, alpha, N_discr, skipFirst, method)
}
\arguments{
\item{N}{integer - Number of iterations}

\item{x0}{double - starting value}

\item{r}{double - controll parameter}

\item{alpha}{double - exponent of general symmetric map}

\item{N_discr}{integer - controlls discretization of state space (zero corresponds to continuous case)}

\item{skipFirst}{Boolean - If set to FALSE, the resulting time series contains the initial value x0}
}
\value{
vector of type double - the resulting time series
}
\description{
Create time series produced by general symmetric map
}
\details{
This routine is implemented in C++
}
\examples{
//DEFINITION
NumericVector gsm_iter_cpp(int N, double x0, double r, double alpha, int N_discr,bool skipFirst){
  N_discr--; //Decrement because the rounding routine maps to N_discr + 1 values
  Rcpp::NumericVector X(N);
  if(skipFirst){
    if(N_discr == 0){
      X[0] = gsm_cpp(x0,r,alpha);
    }else{
      X[0] = round(gsm_cpp(x0,r,alpha)*N_discr)/N_discr;
    }
  }
  if(N>1){
    if(N_discr == 0){
      for(int i = 1; i<N ; i++){
        X[i] = gsm_cpp(X[i-1],r,alpha);
      }
    }else{
      for(int i = 1; i<N ; i++){
        X[i] = round(gsm_cpp(X[i-1],r,alpha)*N_discr)/N_discr;
      }
    }
  }
  return(X);
}
}
\author{
J.C. Lemm, P. v.W. Crommelin
}
