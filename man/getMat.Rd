% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{getMat}
\alias{getMat}
\title{discretize the continuous general symmetric map}
\usage{
getMat(r, alpha, N_discr)
}
\arguments{
\item{r}{double - control parameter}

\item{alpha}{double - exponent}

\item{N_discr}{integer - range of output matrix}
}
\value{
matrix of type double - the corresponding matrix of range N
}
\description{
This function converts the continuous general symmetric map into a matrix
}
\details{
This routine is implemented in C++.
}
\examples{
Rcpp::NumericMatrix getMat(double r, double alpha, int N_discr){
  //grid is defined by N_discr values and therefore stepsize dx:
  double dx = 1.0/(N_discr-1.0);
  Rcpp::NumericVector codomain(N_discr);
  for(int i=0 ; i<N_discr ; i++){
    codomain[i] = gsm_cpp(i*dx,r,alpha);
  }
  //get indexposition on defined grid
  Rcpp::NumericVector index(N_discr);
  double diff(N_discr);
  for (int j=0 ; j<N_discr ; j++){
    double min_diff = 1.0; //1.0 is the maximum distance
    for (int i=0 ; i<N_discr ; i++){
      diff = abs(codomain[j] - i*dx);
      if(diff<=min_diff){
        min_diff = diff;
        index[j] = i;
        }
    }
  }
  Rcpp::NumericMatrix A(N_discr,N_discr);
  //consider "ROW MAJOR ORDER" (Wikipedia) to loop over arrays in c/c++
  //not implemented here
  for (int i=0 ; i<N_discr ; i++){
    for (int j=0 ; j<N_discr ; j++){
      if (j == index[i]){
        A(j,i) = 1.0;
      }else{
        A(j,i) = 0.0;
      }
    }
  }
  return(A);
}
}
\references{
S. Sprott, Chaos and Time-series analysis
}
\author{
J.C. Lemm, P.v.W. Crommelin
}
