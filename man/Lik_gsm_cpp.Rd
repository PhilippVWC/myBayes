% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{Lik_gsm_cpp}
\alias{Lik_gsm_cpp}
\title{Gaussian likelihood for given time series data}
\usage{
Lik_gsm_cpp(alpha, r, x0, Y, sigma, N_discr, method)
}
\arguments{
\item{alpha}{Double - Exponent of the gsm.}

\item{r}{Double - Control parameter of the gsm.}

\item{x0}{Double - Initial value of the time series.}

\item{Y}{Vector of type double - The given data.}

\item{sigma}{Double - The standard deviation of the gaussian likelihood.}

\item{N_discr}{Integer - Discretization of the state space (N_discr = 0 -> continuous case).}

\item{method}{Integer - Discretization with 1... R's core round routine (fast) or 2...A Matrix multiplication (slower)}
}
\description{
Lik_gsm_cpp produces a time Series generated by the general symmetric map (gsm)
and computes the its gaussian likelihood given the supplied data. The standart deviation sigma is
equal for every datapoint in this implementation. Eventually supply a single scalar value of type double.
}
\details{
This routine is implemented in C++.
}
\examples{
r = 0.99 # True but hidden control parameter of the general symmetric map (to be reconstructed)
x0 = 0.2 # starting value
alpha = 2.0
N = 20
SIGMA = 0.1
N_discr = 0 # coded value for continuous time series
  Series = rep(x0,N)
  Series = myBayes::gsm_iter_cpp(alpha = alpha,
                                 r = r,
                                 x0 = x0,
                                 N = N,
                                 skipFirst = TRUE,
                                 N_discr = N_discr,
                                 method = 1)
  Y = Series + rnorm(n = N,
                     mean = 0,
                     sd = SIGMA) # add noise (gauss distributed)

  vec = seq(from = 0.95,
            to = 1.0,
            by = 0.000001)

  Lik = sapply(X = vec,
               FUN = function(val) myBayes::Lik_gsm_cpp(alpha = alpha,
                              r = val,
                              x0 = x0,
                              Y = Y,
                              sigma = SIGMA,
                              N_discr = N_discr,
                              method = 1))
  par(mfrow = c(2,1))
  plot(x = 1:N,
       y = Y,
       main = "Given data",
       xlab = "iteration",
       ylab = "Value of timeSeries",
       col = "red",
       type = "l")
  points(x = 1:N,
         y = Y,
         col = "red",
         cex = 1.5,
         pch = 16)
  grid()
  plot(x = vec,
       y = Lik,
       main = "Gaussian likelihood as a function of control parameter r given the data",
       xlab = "control parameter r",
       ylab = "Likelihood",
       cex = 0.5,
       pch = 16)
  lines(x = rep(r,2),
        y = c(0,max(Lik)),
        col = "red",
        lwd = 3,
        lty = 1)
  grid()
  legend("topleft",
         leg = paste0("Real value for r = ",r),
         col = "red",
         lty = 1,
         lwd = 3)


#C++ DEFINITION:
#double Lik_gsm_cpp(double alpha, double r, double x0, NumericVector Y, double sigma, int N_discr){
#  int n = Y.size(); //Because equally the generated skips first datapoint
#  bool skipFirst = true;
#  Rcpp::NumericVector X = gsm_iter_cpp(n,x0,r,alpha,N_discr,skipFirst);
#  double sum = 0;
#  for(int i = 0; i<n ; i++){
#    sum += pow(Y[i]-X[i],2.0);
#  }
#  double L = pow(2.0*PI*pow(sigma,2),-0.5*n)*exp(-0.5*sum/pow(sigma,2.0));
#  return(L);
#}
}
\references{
S. Sprott, Chaos and Time-series analysis
}
\author{
J.C. Lemm, P. v.W. Crommelin
}
